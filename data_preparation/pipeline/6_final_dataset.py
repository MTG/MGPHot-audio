import json
import re
from typing import Optional, Dict, List

# ----------------------------------------------------------------------
# settings
# ----------------------------------------------------------------------

DATASET_FILE = "dataset_with_youtube.json"
MANUAL_FILE  = "manual_annotation_reviewed.json"
OUTPUT_FILE  = "official_or_first_match_from_dataset.json"

EXCLUDED_IDS = {
    "2BMSx8HVOA8", "Z5KlFk1EqXE", "NCeRZw6hhX8", "0bcYxH65kSg",
    "5-awGmWdFpA", "Tr7idRiR0Yw", "SIlZk4qoO1c", "joWPQLVByqo",
    "zns8Y8phigk", "0CuO2ZpqkBM"
}

MANUAL_OVERRIDES = {
    "11844": {   # Jon B â€“ They Don't Know
        "manual_youtube_link": "https://www.youtube.com/watch?v=AS8cpOluyz4"
    }
}

# ----------------------------------------------------------------------
# helpers
# ----------------------------------------------------------------------

def get_youtube_id(url: str) -> Optional[str]:
    m = re.search(r"(?:v=|youtu\.be/)([\w\-]{11})", url)
    return m.group(1) if m else None

def is_official(upl: str, desc: str, artist: Optional[str]) -> bool:
    u = upl.lower().strip()
    d = desc.lower().strip()
    a = (artist or "").lower()
    return (
        re.search(r"\s?-?\s?topic\Z", u) or
        u.endswith("vevo") or
        "provided to youtube by" in d or
        "auto-generated by youtube" in d or
        (a and a in u)
    )

# ----------------------------------------------------------------------
# load datasets
# ----------------------------------------------------------------------

with open(DATASET_FILE, "r", encoding="utf-8") as f:
    main_data: List[Dict] = json.load(f)

with open(MANUAL_FILE, "r", encoding="utf-8") as f:
    manual_data: List[Dict] = json.load(f)

tracks: Dict[str, Dict] = {}

for tr in main_data:
    tid = str(tr["mgphot_track_id"])
    if "gene_values" not in tr:
        raise ValueError(f"Missing gene_values for track id {tid}")
    tracks[tid] = tr

for tr in manual_data:
    tid = str(tr["mgphot_track_id"])
    if "gene_values" not in tr:
        raise ValueError(f"Missing gene_values for track id {tid} in manual file")
    if tid in tracks:
        if tr.get("manual_youtube_link"):
            tracks[tid]["manual_youtube_link"] = tr["manual_youtube_link"]
    else:
        tracks[tid] = tr

for tid, extra in MANUAL_OVERRIDES.items():
    if tid not in tracks:
        raise ValueError(f"Override id {tid} not found in datasets")
    tracks[tid]["manual_youtube_link"] = extra["manual_youtube_link"]

# ----------------------------------------------------------------------
# pick one link per track
# ----------------------------------------------------------------------

output: Dict[str, Dict] = {}
missing: List[str] = []
cnt_official = 0
cnt_excluded = 0

for tid, tr in tracks.items():
    artist = tr.get("artist", "").strip()
    title  = tr.get("title", "").strip()
    gene   = tr["gene_values"]

    # build candidate list
    cands: List[Dict] = []
    for vid in tr.get("youtube", []):
        url = vid.get("link", "")
        vid_id = get_youtube_id(url)
        if vid_id and vid_id not in EXCLUDED_IDS:
            cands.append({
                "url": url,
                "id": vid_id,
                "upl": vid.get("uploader", ""),
                "desc": vid.get("description", "")
            })
    manual = tr.get("manual_youtube_link")
    if manual:
        vid_id = get_youtube_id(manual)
        if vid_id and vid_id not in EXCLUDED_IDS:
            cands.insert(0, {
                "url": manual,
                "id": vid_id,
                "upl": "manual",
                "desc": ""
            })

    if not cands:
        cnt_excluded += 1
        missing.append(f"{tid} â€“ {artist} â€“ {title}")
        continue

    chosen = None
    official = False
    for c in cands:
        if is_official(c["upl"], c["desc"], artist):
            chosen = c
            official = True
            break
    if not chosen:
        chosen = cands[0]

    if official:
        cnt_official += 1

    output[tid] = {
        "artist":      artist,
        "title":       title,
        "youtube_url": chosen["url"],
        "youtube_id":  chosen["id"],
        "is_official": official,
        "gene_values": gene   # keep list for custom writer
    }

# ----------------------------------------------------------------------
# custom save: gene_values on one line, everything else indented
# ----------------------------------------------------------------------

def dump_track(d: Dict, indent: str = "    ") -> str:
    """Return JSON fragment for one track with gene_values inline."""
    lines = []
    lines.append('{')
    lines.append(f'{indent}"artist": {json.dumps(d["artist"])},')
    lines.append(f'{indent}"title": {json.dumps(d["title"])},')
    lines.append(f'{indent}"youtube_url": {json.dumps(d["youtube_url"])},')
    lines.append(f'{indent}"youtube_id": {json.dumps(d["youtube_id"])},')
    lines.append(f'{indent}"is_official": {"true" if d["is_official"] else "false"},')
    # gene_values in one compact line
    gv = json.dumps(d["gene_values"], separators=(",", ":"))
    lines.append(f'{indent}"gene_values": {gv}')
    lines.append('}')
    return "\n".join(lines)

# with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
#     f.write("{\n")
#     total_items = len(output)
#     for idx, (tid, data) in enumerate(output.items()):
#         comma = "," if idx < total_items - 1 else ""
#         f.write(f'  "{tid}": {dump_track(data)}{comma}\n')
#     f.write("}\n")

# ----------------------------------------------------------------------
# report
# ----------------------------------------------------------------------

if missing:
    print("\nâŒ tracks without any valid link:")
    for m in missing:
        print("  -", m)

total = len(output)
print("\nğŸ“Š SUMMARY")
print("Tracks selected :", total)
print("Official videos  :", cnt_official)
print("Excluded tracks  :", cnt_excluded)
print("Official ratio   : {:.2f}%".format(100 * cnt_official / total if total else 0))
print(f"\nâœ… File written: {OUTPUT_FILE}")
